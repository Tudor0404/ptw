// AUTOGENERATED FILE
// This file was generated from schedule-grammar.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface ScheduleGrammarActionDict<T> extends BaseActionDict<T> {
  Expression?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ConditionExpression?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  OrExpression_or?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  OrExpression_commaOr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  OrExpression?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AndExpression_and?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  AndExpression_dotAnd?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  AndExpression?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  NotExpression_not?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  NotExpression_bangNot?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  NotExpression?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  OptimizationExpression_noMergeNot?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  OptimizationExpression_forceMergeNot?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  OptimizationExpression_noMerge?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  OptimizationExpression_forceMerge?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  OptimizationExpression?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  NotOperation_not?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  NotOperation_bangNot?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  NotOperation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PrimaryExpression_paren?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PrimaryExpression_value?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  PrimaryExpression?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ParenthesisExpression?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  ValueBlock?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  TimeBlock?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  TimeRange?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  Time?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  HourTime?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
  MinuteTime?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: IterationNode, arg5: IterationNode) => T;
  SecondTime?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: IterationNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: IterationNode, arg8: IterationNode) => T;
  MillisecondTime?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: IterationNode, arg5: TerminalNode, arg6: NonterminalNode, arg7: IterationNode, arg8: TerminalNode, arg9: NonterminalNode, arg10: IterationNode, arg11: IterationNode, arg12: IterationNode) => T;
  WeekDayBlock?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  DateBlock?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  MonthBlock?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  MonthDayBlock?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  YearBlock?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  DateTimeBlock?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  DateTimeList?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DateTimeRange?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  DateTime?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  date?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: NonterminalNode, arg3: NonterminalNode, arg4: TerminalNode, arg5: NonterminalNode, arg6: NonterminalNode, arg7: TerminalNode, arg8: NonterminalNode, arg9: NonterminalNode) => T;
  ScheduleBlock?: (this: NonterminalNode, arg0: TerminalNode, arg1: TerminalNode, arg2: NonterminalNode, arg3: TerminalNode) => T;
  ReferenceId?: (this: NonterminalNode, arg0: IterationNode) => T;
  ValueList?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ValueExpr_range?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: IterationNode) => T;
  ValueExpr_algebraic?: (this: NonterminalNode, arg0: IterationNode, arg1: TerminalNode, arg2: TerminalNode, arg3: IterationNode) => T;
  ValueExpr_number?: (this: NonterminalNode, arg0: IterationNode) => T;
  ValueExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DateList?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DateExpr_range?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;
  DateExpr_single?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  DateExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
}

export interface ScheduleGrammarSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: ScheduleGrammarActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: ScheduleGrammarActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: ScheduleGrammarActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: ScheduleGrammarActionDict<T>): this;
}

export interface ScheduleGrammarGrammar extends Grammar {
  createSemantics(): ScheduleGrammarSemantics;
  extendSemantics(superSemantics: ScheduleGrammarSemantics): ScheduleGrammarSemantics;
}

declare const grammar: ScheduleGrammarGrammar;
export default grammar;

